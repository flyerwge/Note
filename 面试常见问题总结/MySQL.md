# MySQL常见问题

## 1 MySQL概念性问题

存储引擎：存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据、如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法

### 1.1 常见的存储引擎

- Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
- MyISAM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键，只支持并发插入的表锁，主要用于高负载的select（MyISAM强调快速读取操作）；MyISAM也是使用B+树索引但和Innodb在具体实现上会有不同；
- MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。

### 1.2 Innodb引擎与MyISAM引擎的区别

1. InnoDB支持事务，具有提交（COMMIT）和回滚(ROLLBACK)事务的能力，MyISAM不支持事务；
2. InnoDB支持行级锁和表级锁，MyISAM仅支持表级锁；
3. InnoDB支持外键的约束，MyISAM不支持；
4. 仅InnoDB支持MVCC，应对高并发事务，MVCC比单纯的加锁更加高效。MVCC仅在read committed和repeatable read两个隔离级别下工作。
5. InnoDB是聚集索引，使用B+树作为索引结构，数据文件是和（主键）索引绑在一起的；MyISAM是非聚集索引，也是使用B+树作为索引结构，但是索引和数据文件是分离的，索引保存的是数据文件的指针；（也就是说，InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针）
6. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描，而MyISAM用一个变量保存了整个表的行数，执行上述语句只需要读出该变量即可，速度很快；
7. **重要**:Innodb支持数据库异常崩溃后的安全恢复，MyISAM不支持；
8. InnoDB的数据和索引是存储在同一个文件中的，而MyISAM的数据和索引是分开存储的；

### 1.3 索引

**索引**：用于快速查询和检索数据的数据结构，常见的索引结构有：B树、B+树和Hash；索引和实际数据都是存储在磁盘中，只不过在进行数据读取时会优先将索引加载到内存中

**索引使用B+树的原因**：只在叶子节点中存储数据，（非叶子节点中只存储指针与键值，大大提升空间利用率，需要的I/O次数更少）

**MySQL不使用哈希表作为索引的原因**：Hash索引不支持顺序和范围查询，当需要进行范围查找的时候需要挨个遍历，效率较低；并且hash算法不好的话，会导致hash碰撞，导致数据散列不均匀（memory引擎支持hash索引）

#### 1.3.1 聚集索引与非聚集索引

- 聚集索引：将数据存储与索引放到了一起，找到索引也就找到了数据；
- 非聚集索引：将数据存储与索引分开，索引的叶子节点指向数据文件的地址指针；

**区别**：

1. 聚集索引一个表只能有一个，非聚集索引一个表可以存在多个；
2. 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续；
3. 聚集索引的物理存储按照索引排序，索引的键值逻辑顺序决定了表数据的物理存储顺序；非聚集索引物理存储不按照索引排序，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序；
4. 聚集索引的叶子节点就是数据节点，而非聚集索引的叶子节点是数据文件的地址指针；

**优缺点**：聚集索引插入数据时速度要慢（时间主要浪费在物理存储的排序，需要首先找到位置然后插入）；但是查询数据比非聚集索引要快；

#### 1.3.2 索引有关名词

**回表**：查询字段的普通索引的叶子节点存储有id值，再根据id值检索整行记录，回表的效率低，尽量避免回表操作；

**索引覆盖**：索引的叶子节点中包含查询的所有列，不需要回表，效率较高；

**最左匹配**：创建索引的时候可以选择多个列来共同组成索引，叫做组合索引，要遵循最左匹配原则；

**索引下推**：同时以多个条件进行查找，没有索引下推时，先根据一个条件从存储引擎中拉取数据到server层，然后在server层再根据其他条件对数据进行过滤；有了索引下推，将同时根据多个条件来做数据筛选，将筛选后的结果返回给server层（默认开启）；

### 1.6 事务

定义：逻辑上的一组操作，要么都执行，要么都不执行；

数据库事务：保证多个对数据库的操作（即SQL语句）构成一个逻辑上的整体，要么全部执行成功，要么全部不执行；关系型数据库事务都具有ACID特性

**数据库事务隔离级别**：

1. Serializable（串行化）：这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行；这种级别下，“脏读”、“不可重复读”、“幻读”都可以避免，但是执行效率奇差，性能开销也最大；
2. repeatable read（可重复读）：专门针对“不可重复读”，可以有效的避免“不可重复读”，也是MySQL的默认隔离级别，当事务启动时，就不允许进行“修改操作”；可重复读可以有效避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于插入或者删除操作而产生的；
3. read committed（读提交）：只能读到已经提交了的内容，是各种系统最常用的一种隔离级别，也是SQL server和Oracle的默认隔离级别，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读”，但不能避免“幻读”和“不可重复读取”；
4. read uncommitted（读未提交）：可以读到未提交的内容，在这种隔离级别下，查询是不会加锁的，这种隔离级别的一致性最差，可能会产生“脏读”、“幻读”、“不可重复读”；

**脏读、幻读、不可重复读**：

- 脏读：读到了别的事务回滚前的数据，比如说事物B执行过程中修改了数据X，在未提交前，事物A读取了X，而事物B却回滚了，这样事务A就形成了脏读；
- 幻读：事务A先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据，就产生了幻读；
- 不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配；

**ACID特性**：

- 原子性：事务是最小的执行单位，不允许分割；（undo log）
- 一致性：执行事务前后，数据保持一致；
- 隔离性：并发访问数据库的时候，一个事务不被其他事务所干扰；（MVCC）
- 持久性：一个事务被提交后，它对事务的改变是持久的，即使数据库发生故障也不应该对其有任何影响；（redo log）

#### 1.6.1 MVCC：多版本并发控制

- 当前读：读取的是数据的最新版本，并且对读取的记录加锁（update、delete、insert、select...lock in share mode、select...for update）
- 快照读：读取的是历史版本的记录（单纯的select操作）（所有sql操作全是快照读时不会产生幻读问题）

**MVCC**：多版本并发控制，主要是为了提高数据库的并发性能，在发生读-写请求冲突时不用加锁，MVCC只在RR和RC两个隔离级别下工作，解决了脏读、幻读、不可重复读等事务隔离问题；

MVCC为事务分配单向增长的时间戳，为每个数据修改保存一个版本，版本与事务时间戳相关联，通过将将隐藏字段中的事务id与readview中的属性进行对比来实现不同的隔离；

### 1.7 MySQL三大日志

1. undo log：撤销操作的日志，使MySQL中的数据回到某个状态。在事务开始之前，MySQL会将待修改的记录保存到undo log中，如果数据库崩溃或者事务需要回滚时，MySQL可以通过undo log将数据库中数据回滚到之前的状态（据此实现了事务的原子性）；undo log还实现了MySQL事务的多版本并发控制（MVCC），事务未提交前，undo log保存了未提交之前的版本数据，undo log中的数据可以作为旧版本数据的副本或者快照以便其他并发事务进行读取操作
2. redo log：重做日志，保证持久性，在数据库出现意外情况时能够重新执行某种操作。在MySQL中，事务修改的任何数据，都会将最新的数据写入redo log中进行备份；redo log实现事务的持久性：当数据库对数据进行修改的时候，需要把数据页从磁盘读到Buffer中，然后在buffer pool中修改，那么此时buffer pool中的数据就会和磁盘中的数据不一致，此时buffer pool中的数据称为“脏数据”，如果此时发生非正常的数据库重启，那么这些脏数据还没有同步到磁盘中，会发生数据丢失，redo log的作用就是在buffer pool中的数据修改之后，记录相应的修改记录。那么当数据库发生非正常的重启时，可以根据redo log中的记录将脏数据进行重做。当数据操作的脏页被写入磁盘后，redo log的使命完成，此时，redo log占用的空间可以重新利用，会被后续的redo log日志重新覆盖。
3. bin log日志：bin log记录所有MySQL数据库表结构变更以及表数据修改的二进制日志，不会记录select和show这类查询操作的日志，它是一个二进制文件，以事件形式记录，还包含语句所执行的消耗时间等其他额外信息。

### 1.8 数据库连接池

一次SQL请求会建立一个连接，多个请求会建立多个连接，使用完再都去关闭，会造成不必要的浪费和性能的下降；采用连接池节省了不断创建与销毁线程的开销

## 2 语句问题

### 2.1 dorp、delete和truncate的区别

1. 用法不同：

   - drop（丢弃数据）：在删除表的时候使用，直接将整个表删除；
   - delete（删除数据）：删除表中数据；
   - truncate（清空数据）：只删除表中的数据，再插入数据的时候自增长id又从1开始，在清空表中的数据时使用；

   truncate和不带where子句的delete、drop都会删除表中的数据，但是truncate和delete只删除数据不删除表的结构，drop则会将表一起删除

2. 执行速度不同：一般来说：drop>truncate>delete

3. 属于不同的数据库语言：truncate和drop属于数据定义语句，操作立即生效，不能回滚；delete语句属于数据库操作语句，这个操作会回滚，事务提交之后才生效；

### 2.2 char和varchar的区别

- char：固定长度类型，优点是效率高，缺点是占用空间
- varchar：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节

## 3 数据库设计

### 3.1 设计步骤

1. 需求分析：分析用户的需求，包括数据、功能和性能需求
2. 概念结构设计：主要采用E-R模型进行设计
3. 逻辑结构设计：将E-R图转换成表，实现从E-R模型到关系模型的转换
4. 物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径
5. 数据库实施：包括编程、测试和运行
6. 数据库的运行和维护：系统的运行和数据库的日常维护

### 3.2 E-R图

实体-联系图：用来捋清数据库设计

### 3.3 数据库范式

1. 第一范式：字段不能再分割，每个字段只能是一个值，第一范式是所有关系型数据库的基本要求；
2. 第二范式：在第一范式的基础上，消除了非主属性对于码的部分函数依赖，使得非主属性都依赖于主键；
3. 第三范式：在第二范式的基础上，消除了非主属性对于码的传递函数依赖，符合第三范式要求的数据库设计，基本上解决了数据冗余过大、插入异常、修改异常、删除异常的问题；

**反范式**：一个完全按照范式设计的冗余极低的数据库，很可能在性能上会输给冗余相对多一些的数据库（比如第三范式，表多、数据复杂，数据库的IO次数很多，性能会受到影响）

### 3.4 数据库的优化

1. 优化数据库表的结构（如字段的数据类型、数据类型的长度、存储引擎的选择）
2. 加索引
3. 分库分表
4. SQL语句优化
5. 增加缓存层（如Redis）

**如何回答面试中的优化问题**：首先，一般的优化并不是出现问题才进行优化，在数据库建模和数据库设计的时候会预先考虑到一些优化问题，比如表字段的类型、长度等，包括创建合适的索引等方式，但是这种方式只是提前的预防，并不一定能解决所有的问题；然后，当生产环境中已经出现sql问题之后主要从数据库的性能监控、索引的创建和维护、sql语句的调整、参数的设置、架构的调整等多个方面进行综合考虑；

## 4 数据库锁

- 乐观锁：利用CAS机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，实现版本判断；
- 悲观锁：悲观锁一般利用select...for update类似的语句，对数据加锁，避免其他事务意外修改数据；

### 4.1 行级锁与表级锁的区别

- 表级锁：MySQL中锁定粒度最大的一种锁，，对当前操作的整张表加锁，实现简单，资源消耗也比较少，不会出现死锁；但因其锁定粒度最大，触发锁冲突的概率最高，并发度最低；
- 行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行加锁，行级锁能大大减小数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁；