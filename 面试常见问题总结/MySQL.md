# MySQL常见问题

## 1 MySQL存储引擎

存储引擎：存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据、如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法

### 1.1 常见的存储引擎

- Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
- MyISAM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键，只支持并发插入的表锁，主要用于高负载的select（MyISAM强调快速读取操作）；MyISAM也是使用B+树索引但和Innodb在具体实现上会有不同；
- MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。

### 1.2 Innodb引擎与MyISAM引擎的区别

1. InnoDB支持事务，MyISAM不支持；
2. InnoDB支持行级锁和外键的约束，MyISAM仅支持表级锁；
3. InnoDB是聚集索引，使用B+树作为索引结构，数据文件是和（主键）索引绑在一起的；MyISAM是非聚集索引，也是使用B+树作为索引结构，但是索引和数据文件是分离的，索引保存的是数据文件的指针；（也就是说，InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针）
4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描，而MyISAM用一个变量保存了整个表的行数，执行上述语句只需要读出该变量即可，速度很快；

### 1.3 聚集索引和非聚集索引

- 聚集索引：将数据存储与索引放到了一起，找到索引也就找到了数据；
- 非聚集索引：将数据存储与索引分开，索引的叶子节点指向数据文件的地址指针；

**区别**：

1. 聚集索引一个表只能有一个，非聚集索引一个表可以存在多个；
2. 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续；
3. 聚集索引的物理存储按照索引排序，索引的键值逻辑顺序决定了表数据的物理存储顺序；非聚集索引物理存储不按照索引排序，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序；
4. 聚集索引的叶子节点就是数据节点，而非聚集索引的叶子节点是数据文件的地址指针；

**优缺点**：聚集索引插入数据时速度要慢（时间主要浪费在物理存储的排序，需要首先找到位置然后插入）；但是查询数据比非聚集索引要快；

## 2 语句问题

### 2.1 dorp、delete和truncate的区别

1. 用法不同：

   - drop（丢弃数据）：在删除表的时候使用，直接将整个表删除；
   - delete（删除数据）：删除表中数据；
   - truncate（清空数据）：只删除表中的数据，再插入数据的时候自增长id又从1开始，在清空表中的数据时使用；

   truncate和不带where子句的delete、drop都会删除表中的数据，但是truncate和delete只删除数据不删除表的结构，drop则会将表一起删除

2. 执行速度不同：一般来说：drop>truncate>delete

3. 属于不同的数据库语言：truncate和drop属于数据定义语句，操作立即生效，不能回滚；delete语句属于数据库操作语句，这个操作会回滚，事务提交之后才生效；

## 3 数据库设计

### 3.1 设计步骤

1. 需求分析：分析用户的需求，包括数据、功能和性能需求
2. 概念结构设计：主要采用E-R模型进行设计
3. 逻辑结构设计：将E-R图转换成表，实现从E-R模型到关系模型的转换
4. 物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径
5. 数据库实施：包括编程、测试和运行
6. 数据库的运行和维护：系统的运行和数据库的日常维护

### 3.2 E-R图

实体-联系图：用来捋清数据库设计

### 3.3 数据库范式

1. 第一范式：字段不能再分割，每个字段只能是一个值，第一范式是所有关系型数据库的基本要求；
2. 第二范式：在第一范式的基础上，消除了非主属性对于码的部分函数依赖，使得非主属性都依赖于主键；
3. 第三范式：在第二范式的基础上，消除了非主属性对于码的传递函数依赖，符合第三范式要求的数据库设计，基本上解决了数据冗余过大、插入异常、修改异常、删除异常的问题；

**反范式**：一个完全按照范式设计的冗余极低的数据库，很可能在性能上会输给冗余相对多一些的数据库（比如第三范式，表多、数据复杂，数据库的IO次数很多，性能会受到影响）

### 3.4 数据库的优化

1. 优化数据库表的结构（如字段的数据类型、数据类型的长度、存储引擎的选择）
2. 分表
3. SQL语句优化
4. 增加缓存层（如Redis）