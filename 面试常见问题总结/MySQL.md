# MySQL常见问题

## 1 MySQL概念性问题

存储引擎：存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据、如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法

### 1.1 常见的存储引擎

- Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
- MyISAM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键，只支持并发插入的表锁，主要用于高负载的select（MyISAM强调快速读取操作）；MyISAM也是使用B+树索引但和Innodb在具体实现上会有不同；
- MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。

### 1.2 Innodb引擎与MyISAM引擎的区别

1. InnoDB支持事务，具有提交（COMMIT）和回滚(ROLLBACK)事务的能力，MyISAM不支持事务；
2. InnoDB支持行级锁和表级锁，MyISAM仅支持表级锁；
3. InnoDB支持外键的约束，MyISAM不支持；
4. InnoDB是聚集索引，使用B+树作为索引结构，数据文件是和（主键）索引绑在一起的；MyISAM是非聚集索引，也是使用B+树作为索引结构，但是索引和数据文件是分离的，索引保存的是数据文件的指针；（也就是说，InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针）
5. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描，而MyISAM用一个变量保存了整个表的行数，执行上述语句只需要读出该变量即可，速度很快；
6. **重要**:Innodb支持数据库异常崩溃后的安全恢复，MyISAM不支持；

### 1.3 聚集索引和非聚集索引

- 聚集索引：将数据存储与索引放到了一起，找到索引也就找到了数据；
- 非聚集索引：将数据存储与索引分开，索引的叶子节点指向数据文件的地址指针；

**区别**：

1. 聚集索引一个表只能有一个，非聚集索引一个表可以存在多个；
2. 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续；
3. 聚集索引的物理存储按照索引排序，索引的键值逻辑顺序决定了表数据的物理存储顺序；非聚集索引物理存储不按照索引排序，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序；
4. 聚集索引的叶子节点就是数据节点，而非聚集索引的叶子节点是数据文件的地址指针；

**优缺点**：聚集索引插入数据时速度要慢（时间主要浪费在物理存储的排序，需要首先找到位置然后插入）；但是查询数据比非聚集索引要快；

### 1.4 行级锁与表级锁的区别

- 表级锁：MySQL中锁定粒度最大的一种锁，，对当前操作的整张表加锁，实现简单，资源消耗也比较少，不会出现死锁；但因其锁定粒度最大，触发锁冲突的概率最高，并发度最低；
- 行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行加锁，行级锁能大大减小数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁；

### 1.5 事务

定义：逻辑上的一组操作，要么都执行，要么都不执行；

数据库事务：保证多个对数据库的操作（即SQL语句）构成一个逻辑上的整体，要么全部执行成功，要么全部不执行；关系型数据库事务都具有ACID特性

数据库事务隔离级别：

1. Serializable（串行化）：这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行；这种级别下，“脏读”、“不可重复读”、“幻读”都可以避免，但是执行效率奇差，性能开销也最大；
2. repeatable read（可重复读）：专门针对“不可重复读”，可以有效的避免“不可重复读”，也是MySQL的默认隔离级别，当事务启动时，就不允许进行“修改操作”；可重复读可以有效避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于插入或者删除操作而产生的；
3. read committed（读提交）：只能督读到已经提交了的内容，是各种系统最常用的一种隔离级别，也是SQL server和Oracle的默认隔离级别，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读”，但不能避免“幻读”和“不可重复读取”；
4. read uncommitted（读未提交）：可以读到未提交的内容，在这种隔离级别下，查询是不会加锁的，这种隔离级别的一致性最差，可能会产生“脏读”、“幻读”、“不可重复读”；

**脏读、幻读、不可重复读**：

- 脏读：读到了别的事务回滚前的数据，比如说事物B执行过程中修改了数据X，在未提交前，事物A读取了X，而事物B却回滚了，这样事务A就形成了脏读；
- 幻读：事务A先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据，就产生了幻读；
- 不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配；

**ACID特性**：

- 原子性：事务是最小的执行单位，不允许分割；
- 一致性：执行事务前后，数据保持一致；
- 隔离性：并发访问数据库的时候，一个事务不被其他事务所干扰；
- 持久性：一个事务被提交后，它对事务的改变是持久的，即使数据库发生故障也不应该对其有任何影响；

## 2 语句问题

### 2.1 dorp、delete和truncate的区别

1. 用法不同：

   - drop（丢弃数据）：在删除表的时候使用，直接将整个表删除；
   - delete（删除数据）：删除表中数据；
   - truncate（清空数据）：只删除表中的数据，再插入数据的时候自增长id又从1开始，在清空表中的数据时使用；

   truncate和不带where子句的delete、drop都会删除表中的数据，但是truncate和delete只删除数据不删除表的结构，drop则会将表一起删除

2. 执行速度不同：一般来说：drop>truncate>delete

3. 属于不同的数据库语言：truncate和drop属于数据定义语句，操作立即生效，不能回滚；delete语句属于数据库操作语句，这个操作会回滚，事务提交之后才生效；

## 3 数据库设计

### 3.1 设计步骤

1. 需求分析：分析用户的需求，包括数据、功能和性能需求
2. 概念结构设计：主要采用E-R模型进行设计
3. 逻辑结构设计：将E-R图转换成表，实现从E-R模型到关系模型的转换
4. 物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径
5. 数据库实施：包括编程、测试和运行
6. 数据库的运行和维护：系统的运行和数据库的日常维护

### 3.2 E-R图

实体-联系图：用来捋清数据库设计

### 3.3 数据库范式

1. 第一范式：字段不能再分割，每个字段只能是一个值，第一范式是所有关系型数据库的基本要求；
2. 第二范式：在第一范式的基础上，消除了非主属性对于码的部分函数依赖，使得非主属性都依赖于主键；
3. 第三范式：在第二范式的基础上，消除了非主属性对于码的传递函数依赖，符合第三范式要求的数据库设计，基本上解决了数据冗余过大、插入异常、修改异常、删除异常的问题；

**反范式**：一个完全按照范式设计的冗余极低的数据库，很可能在性能上会输给冗余相对多一些的数据库（比如第三范式，表多、数据复杂，数据库的IO次数很多，性能会受到影响）

### 3.4 数据库的优化

1. 优化数据库表的结构（如字段的数据类型、数据类型的长度、存储引擎的选择）
2. 分表
3. SQL语句优化
4. 增加缓存层（如Redis）