# Redis面试准备

## 1. 什么是Redis

Redis是一个使用C语言开发的数据库，与传统数据库不同点在于Redis是存在内存中的，所以Redis的读写速度非常快，因此Redis被广泛应用于==缓存==方向。

另外，Redis除了做缓存之外，还经常用来做==分布式锁==，甚至是==消息队列==。Redis还支持==事物==、==持久化==、多种==集群==方案等。

## 2. 分布式 缓存常用技术方案

Memcached和Redis

分布式缓存主要解决的问题是单机缓存的容量受服务器限制并且无法保存通用信息。因为，本地缓存只在当前服务里有效。

## 3. Redis和Memcached的区别和共同点

### 共同点：

- 都是基于内存的数据库，一般都用来当作缓存使用；
- 都有过期策略；
- 两者的性能都非常高；

### 区别：

- Redis支持更丰富的数据类型（String（字符串）、list（列表）、hash（哈希）、set（集合）、zset（有序集合）），而Memcached仅支持最简单的key-value数据存储；
- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用，而Memcached把数据全部保存在内存中；
- Redis有灾难恢复机制，因为可以把缓存的数据持久化到磁盘上；
- Redis原生支持集群模式，Memcached需要依靠客户端来实现往集群中分片写入数据；
- Redis支持发布订阅模型、Lua脚本、事物等功能，而Memcached不支持；

## 4. 缓存数据的处理流程

1. 如果用户请求的数据在缓存中就直接返回；
2. 缓存中不存在的话就看数据库中是否存在；
3. 数据库中存在的话就更新缓存中的数据；
4. 数据库中不存在的话就返回空数据。

## 5. 为什么要用Redis/为什么要用缓存

### 高性能：

用户第一次访问数据库中的某些数据的话，过程会比较慢，但是如果用户访问的数据属于==高频数据==并且==不会经常改变==，就可以选择将用户访问的数据存在缓存中，保证用户下一次访问这些数据的时候可以直接从缓存中获取；

### 高并发:

一般像MySQL这类的数据库的QPS在1w左右，而使用Redis缓存之后很容易达到10w+，直接操作缓存能够承受的数据请求数量将远远大于直接访问数据库的。考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库，进而提高系统整体的并发。

## 6. Redis常见数据结构及使用场景分析

## String:

**介绍**：string数据结构是简单的key-value类型，不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度的复杂度为O(1)，除此之外，Redis的SDS API是安全的，不会造成缓冲区溢出；

**应用场景**：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

### list：

**介绍**：链表，易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。Redis的list实现为一个双向链表，可以支持反向查找和遍历，不过带来了部分额外的内存开销；（通过rpush和rpop可以实现栈）

**应用场景**：发布与订阅，或者说消息队列、慢查询。

### hash:

**介绍**：hash是一个string类型的field和value的映射表，特别适合用于存储对象，后续操作的时候可以直接修改这个对象中的某个字段值；

**用户信息**：系统中对象数据的存储，如用户信息、商品信息等等；

### set：

**介绍**：Redis的set是一种无序集合，存储的列表数据不会出现重复数据，可以基于set轻易实现交集、并集、差集的操作；

**应用场景**：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景。

### zset：

**介绍**：和set相比，zset增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，还可以通过score的范围来获取元素的列表；

**应用场景**：需要对数据某个权重进行排序，如直播系统实时排序的在线用户列表、礼物排行榜等。

### bitmap：

**介绍**：存储的是连续的二进制数字，通过bitmap只需要一个比特位来表示某个元素对应的值或状态，key就是对应元素本身；bitmap本身会极大的节省储存空间；

**应用场景**：适合需要保存状态信息（如是否签到、是否登录）并需要对这些信息进行分析的场景。

## 7. Redis单线程模型

Redis通过IO多路复用程序来监听来自客户端的大量连接，它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。IO多路复用技术的使用让Redis不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。Redis服务器需要处理两类事件：1.文件事件；2.时间事件

文件事件处理器主要包含四个部分：

- 多个socket（客户端连接）
- IO多路复用程序（使得文件事件处理器能够以单线程方式运行，并支持多个客户端连接）
- 文件事件分派器（将socket关联到相应的事件处理器）
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

## 8. Redis6.0之前为什么不使用多线程

1. 单线程编程容易并且更易维护；
2. Redis性能瓶颈不在CPU，主要在于内存和网络；
3. 多线程存在死锁、线程上下文切换等问题；

## 9. Redis6.0之后为何引入了多线程

Redis6.0引入多线程是为了提高网络IO读写性能（Redis的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行，因此不需要担心线程安全问题）

## 10. Redis给缓存数据设置过期时间的作用

Redis数据是缓存在内存中的，如果缓存中的所有数据都是一直保存的话，会out of memory(虚拟内存不足)，设置过期时间有助于缓解内存的消耗，另外某些场景需要数据只在某一段时间存在（如验证码），通过Redis缓存会更方便；

## 11. Redis如何判断数据是否过期

Redis是通过过期字典（类似hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key，过期字典的值是一个long类型的整数，这个整数保存了key所指向的数据库键的过期时间；

## 12. 过期数据的删除测略

常用的过期数据删除策略：

1. 惰性删除：只会在取出key的时候才对数据进行过期检查，这样对CPU最好，但是可能会造成太多过期的key没有被删除；
2. 定期删除：每隔一段时间抽取一批key执行删除过期key操作。并且Redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；

定期删除对内存更加友好，惰性删除对CPU更加友好，所以Redis采用的是定期删除+惰性删除

## 13. Redis内存淘汰机制

1. volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；
2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰；
3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰；
4. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key；
5. allkeys-random：从数据集中任意选择数据淘汰；
6. no-eviction：当内存不足以容纳新写入数据时，新写入会报错；
7. volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰；
8. allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key；

## 14. Redis持久化机制（保证Redis挂掉之后再重启数据可以进行恢复）

Redis不同于Memcached的很重要的一点是Redis支持持久化。Redis支持两种不同的持久化方式：1）快照；2）只追加文件；

- 快照：Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器的时候使用；
- 只追加文件（AOF）:与快照持久化相比，AOF持久化的实时性更好。开启AOF持久化后会每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入内存缓存中，然后再根据配置来决定什么时候将其同步到硬盘中的AOF文件。

## 15. Redis事务

Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。

- 使用MULTI命令后可以输入多个命令，Redis不会立即执行这些命令，而是将它们放到队列；调用EXEC将执行所有命令；DISCARD命令取消一个事物，会清空事物队列中保存的所有命令；
- WATCH命令用于监听指定的键，当调用EXEC命令执行事物时，如果一个被WATCH命令监视的键被修改的话，整个事物都不会执行，直接返回失败；

事物四大特性：原子性、隔离性、持久性、一致性

## 16. 缓存穿透

**定义**：大量请求的key==不存在于==缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。

**解决方法**：

- 首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端；
- 缓存无效key：如果缓存和数据库都查不到某个key的数据就写到一个Redis中去并设置过期时间，这种方式可以解决请求的key变化不频繁的情况；
- 布隆过滤器：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求是否存在于布隆过滤器中；不存在的话，直接返回请求参数错误。但是，布隆过滤器可能会存在误判的情况：布隆过滤器说某个元素存在，小概率会误判；布隆过滤器说某个元素不在，那么这个元素一定不在。

## 17. 缓存雪崩

**定义**：缓存在同一时间大面积的==失效==，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。另一种场景：有一些被大量访问数据（热点数据）在某一时刻失效，导致对应的请求直接落到了数据库上。

**解决方法**：

- 针对Redis服务不可用（场景一）：1）采用Redis集群，避免单机出现问题整个缓存服务都没办法使用；2）限流，避免同时出现大量请求；
- 针对热点缓存失效的情况（场景二）：1）设置不同的失效时间（如随机设置缓存的失效时间）；2）缓存永不失效；

## 18. 保证缓存和数据库数据的一致性

1. 读操作并不会导致缓存与数据库中的数据不一致：当客户端想读取的数据在缓存中就直接返回数据，即命中缓存；当读取的数据不在缓存内，就需要从数据库中将数据读入缓存，即未命中缓存；
2. 写操作时，缓存与数据库中的内容都需要被修改，可能会导致缓存与数据库中的数据不再一致；
   - 旁路缓存模式：更新数据库，然后直接删除缓存







