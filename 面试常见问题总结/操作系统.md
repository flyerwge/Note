# 操作系统面试问题准备

## 1. 进程管理

### 1.1 进程、线程、协程的区别

1. 进程是资源分配的最小单位，线程是CPU调度的最小单位
2. 一个进程至少有一个线程，进程在执行的过程中也可以产生多个线程
3. 线程执行开销小，但不利于资源的管理和保护，而进程正好相反
4. 进程之间是 相互独立的，而各线程则不一定，同一进程内的线程有可能会相互影响

**协程**：又称微线程，一种用户态的轻量级线程，不像线程和进程一样，需要进行系统内核上的上下文切换，协程的上下文切换由开发人员决定，省去了CPU的切换开销

**协程优缺点**：

- 优点：1）无需系统的上下文切换，减小开销；2）无需原子操作锁定及同步的开销，不用担心资源 共享问题；3）单线程即可实现高并发；
- 缺点：1）无法使用CPU多核；2）处处都要使用非阻塞代码；

### 1.2 进程间通信

1. 匿名管道通信：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。匿名管道通信只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。
2. 有名管道通信：有名管道突破了匿名管道只能在亲缘关系进程间的通信限制，毫无关联的进程可以通过在文件系统中新建的设备文件进行通信。
3. 高级管道通信：将另一个程序当作一个新的进程在在当前程序进程中启动，则它算是当前程序的子进程。
4. 消息队列通信：消息队列通信克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核中的消息链表，发送数据时，消息队列会被分成一个个独立的消息体。
5. 信号量通信：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
6. 信号：信号是进程通信机制中为一的异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件。
7. 共享内存通信：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但是其他进程都可以访问。共享内存是最快的进程间通信方式，但是多个进程之间竞争同一个共享资源会造成数据的错乱。
8. 套接字通信（socket通信）：本地套接字的通信双方均需要具有本地地址，通信双方分别扮演服务端与客户端，两个进程之间互相发送接收数据

线程间通信：1）共享内存；2）消息传递；3）管道流

## 2. 死锁

**定义**：死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法向前推进

**举例说明**：当线程A持有独占锁a，并尝试与获取独占锁b的同时，线程B持有独占锁b，并尝试去获取独占锁a；AB两个线程由于互相持有对方需要的锁而发生的阻塞现象称为死锁。

### 2.1 死锁产生的四个必要条件

1. 互斥条件：该资源任何时刻只由一个线程持有
2. 请求和保持条件：当线程因请求资源而阻塞时，对以获得的资源保持不放
3. 不剥夺条件：线程已获得的资源在未使用完之前不能由其他线程强行剥夺
4. 循环等待条件：在发生死锁时，若干线程之间必然形成一种头尾相接的循环等待关系

### 2.2 **预防死锁**：破坏造成死锁的四个必要条件之一

1. 破坏请求条件：一次性分配所有资源
2. 破坏保持条件：只要有一个资源得不到分配，也不给这个线程分配其他资源
3. 破坏不剥夺条件：当某线程获得了部分资源，但得不到其他资源，则释放已占有的资源
4. 破坏循环等待条件：系统给每类资源赋予一个编号，每一个线程按照编号递增的顺序请求资源，释放资源则相反

### 2.3 **避免死锁**：在资源动态分配的过程中，防止系统进入不安全状态，以避免发生死锁

1. 银行家算法：操作系统按照规则为进程分配资源
   - 当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足，就按当前的申请分配资源，否则就推迟分配
   - 当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没超过则再次测试系统现存资源能否满足该进程需要的最大资源量，若满足则按当前的申请量分配资源，否则也要推迟分配。
2. 安全序列：是指系统能够按照某种进程推进顺序，为每一个进程分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都能够顺序完成。这种推进顺序叫做安全序列。（**系统安全状态**：如果系统能够找到一个安全序列，就称系统处于安全状态）

### 2.4 **解除死锁**：

1. 资源剥夺法：挂起某些死锁进程并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；
2. 撤销进程法：强制撤销部分/全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；
3. 进程回退法：让一个或多个进程回退到足以避免死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

## 3. 孤儿进程和僵尸进程

**孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。

**僵尸进程**：一个使用fork创建子进程，如果子进程退出，而父进程没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

## 4. 文件描述符

**文件描述符**：用于表述指向文件的引用的抽象化的概念

## 5. 用户态和内核态

- 内核态：运行操作系统程序，操作硬件；
- 用户态：运行用户程序；

### 5.1 CPU状态之间的切换

- 用户态->内核态：唯一途径是通过中断、异常、陷入机制；
- 内核态->用户态：设置程序状态字PSW

### 5.2 用户态与内核态的区别

- 内核态和用户态是操作系统的两种运行级别，大部分用户直接面对的程序都是运行在用户态
- 运行在用户态的程序不能直接访问操作系统内核数据结构和程序，程序执行时需要操作系统帮助完成完成某些工作时，就会切换到内核态（比如操作硬件）
- 用户态时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的；内核态时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的；

## 6. 内存管理

操作系统的内存管理主要负责内存的分配与回收，地址转换也就是将逻辑地址转换成相应的物理地址

### 6.1 逻辑地址与物理地址

- 物理地址：真实物理内存中的地址，更具体一点来说就是内存地址寄存器中的地址；
- 逻辑地址：在Java中，一个对象的地址就可以理解为内存中的一个地址，这个地址就是逻辑地址；

### 6.2 虚拟内存

虚拟内存使得程序认为它拥有连续的可用内存（一个连续完整的地址空间），而实际上，它通常是被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并把内存扩展到硬盘空间。

### 6.3 虚拟存储器



## 守护进程

守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。

#

