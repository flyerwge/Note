# Java面试问题准备

## 一、Java基础

### 1.1  面向对象与面向过程的区别以及优缺点

#### 区别：

- 面向过程：面向过程是一种以过程为中心的编程思想，分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用这些函数即可。面向过程就像是一个士兵，每一步作战都需要亲历亲为。
- 面向对象：面向对象是把构成问题事物分解成各个对象，通过对象去描述事物在整个解决问题过程中的行为，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。面向对象就像战场上的指挥官，指挥战斗而不必知道具体执行的过程。

#### 优缺点：

- 面向过程性能比面向对象高，因为类调用时需要实例化，开销比较大，缺点是不易维护；
- 面向对象易维护、易扩展、易复用，因为面向对象有封装、继承、多态的特性，所以可以设计出低耦合的系统，使系统更加灵活，更加易于维护。但是，面向对象的性能比面向过程低。

### 1.2 “==”和equals的区别

- “==”比较基础数据类型时，比较的是他们的值是否相等，比较引用数据类型时，比较的是引用的地址是否相同
- equals比较两个对象的内容是否相等

### 1.3 JVM、JDK、JRE

- JVM：运行java字节码的虚拟机，目的是使用相同的字节码，不同的系统会得到相同的结果
  - 字节码：扩展名为.class的文件，它不面向任何特定的处理器，只面向虚拟机  ==好处==：1）在一定程度上解决了传统解释性语言效率低的问题；同时保留了解释性语言可移植的特点；2）使得Java无须重新编译即可在多种不同的操作系统上运行；
- JRE：java运行时的环境，是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机、Java类库等。但是，它不能用于创建新程序
- JDK：拥有JRE所拥有的一切，还有编译器和工具，能够创建和编译新程序

### 1.4 Java编译与解释并存

Java需要经过先编译、后解释两个步骤，先编译：将Java程序编译生成.class文件；后解释：.class这种字节码必须由Java解释器来执行；

### 1.5Java和C++的区别

- 都是面向对象的语言，都支持继承、封装和多态
- Java有自动管理内存的Java回收机制，不需要程序员手动释放无用内存
- Java不提供指针来直接访问内存，程序内存更加安全
- ······

## 二、Java 集合

- Map：根据键值获取元素。需要排序：TreeMap；不需要排序：HashMap；需要保证线程安全：ConcurrentHashMap
- Set：需要保证唯一元素，不需要则使用List;
- List：不需要保证唯一元素；

使用集合的原因：1. 数组一旦声明，其长度不可变；2. 声明数组时的数据类型决定了数组存储数据的类型，实际开发中，存储的数据类型是多种多样的； 3.数组存储的数据是有序的、可重复的，特点单一。 集合提高了数据存储的灵活性。

### 2.1 ArrayList与LinkedList的区别

- 两者都不保证线程安全；(Vector线程安全)
- ArrayList采用数组存储，支持高效的随机元素访问，因此随机访问时多用ArrayList；LinkedList基于双向链表实现，新增和删除元素时，速度优于ArrayList；
- ArrayList的空间浪费主要在list的列表结尾会预留一定的容量空间，而LinkedList的空间花费主要体现在每一个元素的后继、前驱、数据所占用的空间；

### 2.2 comparable和comparator的区别

- comparable：有一个compareTo(object)方法排序；
- comparator：有一个compare（object1，object2）方法排序；

定制排序：

```java
Collections.sort(arrayList, new Comparator<Integer>(){
    public int compare(Integer o1, Integer o2){
        return o1.compareTo(o2); // 升序排列
    }
})
```

### 2.3 无序性与不可重复性

- 无序性：无序性不等于随机性，无序性是指存储的数据在底层数组中并非按照数组索引的顺序进行存储，而是根据数据的哈希值确定的；
- 不可重复性：添加的元素按照equals判断时，返回false，需要同时重写equals和HashCode;

### 2.4 HashSet、LinkedHashSet、TreeSet异同

- HashSet是Set接口的主要实现类，底层由HashMap实现，线程不安全，可以存储null值；
- LinkedHashSet是HashSet的子类，可以按照添加的顺序遍历；
- TreeSet底层使用红黑树，可以按照添加的顺序进行遍历，排序的方式有自然排序和定制排序；

红黑树：一种自平衡的二叉查找树，具有良好效率，可在`O(logN)`时间内完成查找；

### 2.5 Queue与Deque的区别

- Queue：单端队列，先进先出
- Deque：双端队列，两端均可以插入或者删除元素
  - ArrayDeque和LinkedList都实现了Deque接口，从性能的角度来说ArrayDeque实现队列比LinkedList要好

PriorityQueue：元素出队顺序与优先级相关，即总是优先级最高的元素先出队

### 2.6  HashMap与HashTable的区别

1. 线程安全：HashMap线程不安全，HashTable线程安全（内部使用synchronized）
2. 效率：HashMap效率高
3. HashMap可以存储null的键值，HashTable不允许null的键值

## 3  JVM虚拟机

### 3.1 Java垃圾回收机制

垃圾回收是Java虚拟机（JVM）垃圾回收器提供的一种用于在空闲时间不定时回收无任何引用的对象占据的内存空间的一种机制

## 4 Java并发

### 4.1 新建线程的四种方式

1. 继承Thread类来创建线程
2. 实现Runnable接口
3. 使用Callable和Future创建线程
4. 使用线程池创建线程

### 4.2 结束线程的三种方法

1. 设置退出标志，使线程正常退出，也就是当run()方法完成后线程终止；
2. 使用interrupt()方法中断线程；
3. 使用stop()方法强行终止线程；

### 4.3 Thread和Run方法的区别

- run() 方法只是Thread类中的一个方法，调用Run()方法不会新建线程，仍在主线程中执行任务；
- start()方法会新建一个子线程并执行run()方法中的内容，调用start()方法会有两个线程，一个是当前正在调用start()的主线程，一个是JVM创建的子线程，用来执行run()的内容

