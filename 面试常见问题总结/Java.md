# jJava面试问题准备

## 一、Java基础

### 1.1  面向对象与面向过程的区别以及优缺点

#### 区别：

- 面向过程：面向过程是一种以过程为中心的编程思想，分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用这些函数即可。面向过程就像是一个士兵，每一步作战都需要亲历亲为。
- 面向对象：面向对象是把构成问题事物分解成各个对象，通过对象去描述事物在整个解决问题过程中的行为，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。面向对象就像战场上的指挥官，指挥战斗而不必知道具体执行的过程。

#### 优缺点：

- 面向过程性能比面向对象高，因为类调用时需要实例化，开销比较大，缺点是不易维护；
- 面向对象易维护、易扩展、易复用，因为面向对象有封装、继承、多态的特性，所以可以设计出低耦合的系统，使系统更加灵活，更加易于维护。但是，面向对象的性能比面向过程低。

**面向对象的三大特征**：

- 封装：将数据和操作数据的方法封装起来
- 继承：从已有类得到继承信息来创建新类的过程
- 多态：运行时用相同的代码根据不同类型的实例呈现出不同行为的现象。（分为编译时多态：方法重载；运行时多态：方法重写）

**组合与继承**：组合是指在新类里面创建原有类的对象，重复利用已有类的功能；继承则是从已有类得到信息来创建新类

**多态的表现**：

- 重载：同一个类中有多个同名的方法，但这些方法有着不同的参数（参数个数、类型、顺序不同），编译时根据方法参数不同确认到底执行哪一个方法
- 覆盖/重写：子类可以重写父类的方法，调用子类中重写父类的方法，会把父类中那个完全相同的方法覆盖

**Java创建对象的四种方式**：

1. 使用new关键字
2. 通过反射机制创建对象（Class类的newInstance方法）
3. 使用clone()方法
4. 反序列化

### 1.2 “==”、equals和hashCode的区别

- “==”比较基础数据类型时，比较的是他们的值是否相等，比较引用数据类型时，比较的是引用的地址是否相同
- equals比较两个对象的内容是否相等
- hashCode()方法是从Object类继承的，用来鉴定两个对象是否相等（返回对象在内存中地址转换成的一个int值）；如果没有重写hashCode方法，任何对象的hashCode()方法都是不相等的

**为什么重写equals方法就一定要重写hashCode方法？**

因为如果用到散列表时，如HashSet，HashSet在添加一个元素时，HashSet会先计算对象的hashCode值来获取对象加入的位置（这个位置上可能存在若干个hashCode值相等的对象），然后调用equals方法来检查hashCode想等的对象在内容上是否相等，如果equals方法返回true，那么不会插入；如果equals返回false，那么发生哈希碰撞。

如果我们重写了equals方法而没有重写hashCode方法，那么在插入两个内容相等的对象到HashSet中时，因为这两个hashCode不同，所以尽管这两个对象equals判断为true，这两个对象仍然会添加进HashSet中，这样就会出先两个相等的对象同时出现在HashSet中。

### 1.3 JVM、JDK、JRE

- JVM：运行java字节码的虚拟机，目的是使用相同的字节码，不同的系统会得到相同的结果
  - 字节码：扩展名为.class的文件，它不面向任何特定的处理器，只面向虚拟机  ==好处==：1）在一定程度上解决了传统解释性语言效率低的问题；同时保留了解释性语言可移植的特点；2）使得Java无须重新编译即可在多种不同的操作系统上运行；
- JRE：java运行时的环境，是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机、Java类库等。但是，它不能用于创建新程序
- JDK：拥有JRE所拥有的一切，还有编译器和工具，能够创建和编译新程序

### 1.4 Java编译与解释并存

Java需要经过先编译、后解释两个步骤，先编译：将Java程序编译生成.class文件；后解释：.class这种字节码必须由Java解释器来执行；

### 1.5Java和C++的区别

- 都是面向对象的语言，都支持继承、封装和多态
- Java有自动管理内存的Java回收机制，不需要程序员手动释放无用内存
- Java不提供指针来直接访问内存，程序内存更加安全
- ······

### 1.6 抽象类和接口的区别

Java中接口和抽象类的定义语法分别为interface和abstract关键字

抽象类： 1. 抽象类不能被实例化只能被继承； 2. 子类继承一个抽象类，则子类必须实现抽象类

接口：1. 接口可以包含变量、方法；  2. 接口支持多继承，即一个接口可以extends多个接口，间接解决了Java中类的单继承问题； 3. 一个类可以实现多个接口

**相同点**：都不能被实例化，接口的实现类或抽象类的子类都只有实现了接口或者抽象类中的方法后才能实例化

**区别**：

1. 抽象类可以定义构造函数，接口不能定义构造函数
2. 抽象类中可以有抽象方法和具体方法，而接口中只能有抽象方法
3. 抽象类中可以包含静态方法，而接口中不可以包含静态方法
4. 类可以实现很多接口，但是只能继承一个抽象类

### 1.7 static关键字的特点

1. 方便在没有创建对象的情况下调用
2. static方法内部不能调用非静态方法，反过来则可以
3. static方法必须有实现，static方法不能被重写（static方法是编译时静态绑定的，而方法重写是基于运动时态绑定的）  注：private方法也不能被重写，因为private修饰的类不能被继承，自然不能被重写

作用：

1. 静态变量：又称为类变量，说明这个变量是属于类的
2. 静态方法：在类加载时就已经存在，不依赖于任何实例，所以静态方法必须有实现
3. 静态代码块 ：静态代码块在类初始化的时候运行一次
4. 静态内部类：静态内部类不依赖于外部类

### 1.8 Java关键字final、finally、finalize的区别

1. final：final用来声明属性、方法和类，分别表示属性不可变、方法不可重写和类不可被继承
   - final属性：修饰引用类型时，只能指向初始化时指向的对象，而不能再指向其他对象，但是该引用指向的对象内容可以发生变化
   - final方法：该方法不允许任何子类重写，但子类可以使用
   - final基本数据类型：该基本数据类型的一旦在初始化后便不能发生变化
   - final类：此类不能被继承，所有方法不能被重写
2. finally：异常处理语句的一部分，表示这部分语句最终一定被执行
3. finalize：是Object类的一个方法，在垃圾回收器执行时会被调用（对象空间被回收前），重写此方法用来实现对其他资源的回收，例如关闭文件等

### 1.9 深拷贝和浅拷贝

- 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递（所有拷贝对象指向的地址不变）
- 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容

### 1.10 什么是反射机制

**反射机制**：允许程序在运行时进行自我检查，同时也允许对其内部的成员进行操作。即程序在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。

**获得Class对象的三种方法**：1）对象.getClass()  2）类名.class  3）Class.forName("类的路径")

**反射的优缺点**：

- 优点：反射可以提供运行时的类信息，并且可以在运行时动态地创建类的对象。
- 缺点：如果一个功能可以不用反射完成，那么最好不用：
  - 性能开销：反射操作的效率比非反射低得多
  - 安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行
  - 内部暴露：由于反射机制允许代码执行一些在正常情况下不被允许的操作，可能导致代码失调并破坏可移植性

**反射的应用**：1）Spring的IOC容器；2）反射+工厂模式：使工厂模式更加稳定；3）JDBC连接数据库时加载驱动类

### 1.11 Java异常

**Error和Exception的区别**：

1. 父类都是Throwable类
2. Error：一般是指与虚拟机相关的问题，不希望被程序捕获或者是程序无法处理的错误；
3. Exception：表示用户程序可能捕捉的异常情况或者说是程序可以处理的异常，可以通过catch来进行捕获，分为运行时异常和检查异常
   - RuntimeException：不可预知的，程序应该自行避免（空指针异常，数组越界异常等），编译器没有强制对其进行捕获并处理
   - CheckedException：可预知的，从编译器检验的异常（IO异常和SQL异常等），编译器强制程序去捕获此类型的异常

**Error**：

- OutOfMemoryError：虚拟机内存溢出异常，例如，堆内存溢出：java.lang.OutOfMemoryError:Java heap space；常量池溢出：PermGen space
- StackOverFlowError：线程请求的栈深度大于虚拟机所允许的最大深度（如果栈内存允许动态扩展，当扩展容量无法申请到足够的内存时，将抛出OutOfMemoryError异常）
- VitualMachineError：虚拟机运行错误

**Exception**:

- IOException：
- RunTimeException：

### 1.12 assert的作用

assert（断言）：一种软件调试的方法，提供了一种在代码中进行正确性检查的机制

应用范围：1）检查控制流；2）检查输入参数是否有效；3）检查函数结果是否有效；4）检查程序不变量。

### 1.13 instanceof

**作用**：判断一个引用类型的变量所指的对象是否是一个类（或接口、抽象类、父类）的实例，该运算符返回Boolean类型的数据

### 1.14 round、ceil和floor

- round：四舍五入
- ceil：向上取整
- floor：向下取整

### 1.15 String、StringBuffer、StringBuilder

- String：String是不可变类，String对象一旦被创建，其值将不能被改变
- StringBuffer：对方法加了同步锁，线程安全
- StringBuilder：与StringBuffer类似，都是字符缓冲区，速率较高但线程不安全

**String设为不可变类的原因：**

1. 字符串常量池的需要：当创建一个String对象时，假如此字符串已经存在于字符串常量池中，则直接引用已经存在的对象而不会创建一个新的对象，这样可以在运行时节省堆空间；
2. 允许String字符串缓存HashCode：Java中String对象的哈希码被频繁使用，字符串的不变性保证了hash码的唯一性，因此可以放心的进行缓存；
3. 安全的需要：String被许多Java类库用来当作参数，如URL、文件路径、反射机制所需要的String参数等，固定不变能够避免各种安全隐患；

**StringBuilder的扩容：**

StringBuilder的底层数据结构由一个char[]数组实现，在char[]数组大小不足以容纳新的字符的时候，会进行扩容，而扩容后的大小是原来数组的大小+新字符串的长度

### 1.16 继承

Java原则上是不允许多继承的，而在C++中，类继承不像Java那样只能实行单继承，一个类能够同时继承多个类；Java中可以通过内部类实现多继承的功能。

## 二、Java 集合

- Map：根据键值获取元素。需要排序：TreeMap；不需要排序：HashMap（根据键的HashCode值存储数据）；需要保证线程安全：ConcurrentHashMap
- Set：需要保证唯一元素，不需要则使用List。需要排序：TreeSet；不需要排序：HashSet；
- List：可以保存重复元素，按对象的进入顺序保存对象；LinkedList、ArrayList和Vector都实现了List接口；

使用集合的原因：1. 数组一旦声明，其长度不可变；2. 声明数组时的数据类型决定了数组存储数据的类型，实际开发中，存储的数据类型是多种多样的； 3.数组存储的数据是有序的、可重复的，特点单一。 集合提高了数据存储的灵活性。

### 2.1 ArrayList与LinkedList的区别

- 两者都不保证线程安全；(Vector线程安全)
- ArrayList采用数组存储，支持高效的随机元素访问，因此随机访问时多用ArrayList；LinkedList基于双向链表实现，新增和删除元素时，速度优于ArrayList；
- ArrayList的空间浪费主要在list的列表结尾会预留一定的容量空间，而LinkedList的空间花费主要体现在每一个元素的后继、前驱、数据所占用的空间；

**注**：数组随机访问元素的时间复杂度是`O(1)`，链表随机访问元素的时间复杂度是`O(n)`；

数组访问元素时间复杂度`O(1)`的原因：创建数组必须要一块连续的内存空间，并且数组中存放的是相同的数据类型，因此只需要根据数组的下标就可以计算得到这个数据在内存中的位置；

链表：不同于数组必须要连续的内存空间，链表可以使用零散的的内存空间存储数据。不过，因为链表在内存中的数据是不连续的，所以链表中的每个数据元素都必须包含一个指向下一个数据元素的内存的地址指针。因为链表是不连续的，想要在链表中查找一个数据，必须遍历整个链表，所以说链表的查找复杂度总是`O(n)`，但链表的插入和删除操作复杂度为`O(1)`；

相比在链表中轻易插入、删除一个元素，如果想要在数组中插入、删除一个元素，就会改变数组连续内存空间的大小。需要重新分配内存空间，这样要复杂的多。

### 2.2 comparable和comparator的区别

- comparable：有一个compareTo(object)方法排序；
- comparator：有一个compare（object1，object2）方法排序；

定制排序：

```java
Collections.sort(arrayList, new Comparator<Integer>(){
    public int compare(Integer o1, Integer o2){
        return o1.compareTo(o2); // 升序排列
    }
})
```

### 2.3 无序性与不可重复性

- 无序性：无序性不等于随机性，无序性是指存储的数据在底层数组中并非按照数组索引的顺序进行存储，而是根据数据的哈希值确定的；
- 不可重复性：添加的元素按照equals判断时，返回false，需要同时重写equals和HashCode;

### 2.4 HashSet、LinkedHashSet、TreeSet异同

- HashSet是Set接口的主要实现类，底层由HashMap实现，线程不安全，可以存储null值；
- LinkedHashSet是HashSet的子类，可以按照添加的顺序遍历；
- TreeSet底层使用红黑树，可以按照添加的顺序进行遍历，排序的方式有自然排序和定制排序；

红黑树：一种自平衡的二叉查找树，具有良好效率，可在`O(logN)`时间内完成查找；

### 2.5 Queue与Deque的区别

- Queue：单端队列，先进先出
- Deque：双端队列，两端均可以插入或者删除元素
  - ArrayDeque和LinkedList都实现了Deque接口，从性能的角度来说ArrayDeque实现队列比LinkedList要好

PriorityQueue：元素出队顺序与优先级相关，即总是优先级最高的元素先出队

### 2.6  HashMap、HashTable与ConcurrentHashMap的区别

1. 线程安全：HashMap线程不安全，HashTable线程安全（内部使用synchronized），ConcurrentHashMap线程安全（内部使用使用了Segment分段锁+HashEntry，Segment分段锁继承ReentrantLock，在并发数高的时候，ReentrantLock比Syncronized总体开销要小一些）
2. 效率：HashMap效率高；ConcurrentHashMap>HashTable
3. HashMap可以存储null的键值，HashTable不允许null的键值
4. 

### 2.7 LinkedHashMap与HashMap

1. HashMap不保证存储顺序，LinkedHashMap遍历的时候可以按照输入的顺序输出

### 2.8 Collection和Collections区别

- Collection：集合接口，提供了对集合对象进行基本操作的通用接口方法；
- Collections：针对集合类的一个包装类，提供一系列静态方法以实现对各种集合搜索、排序、线程安全化等操作；

### 2.9 HashMap的底层实现原理

HashMap是用于存储key-value键值对的集合，主要是根据键的hashcode值存储数据；从数据结构上来看，HashMap是由数组+链表+红黑树实现，

- 数组：HashMap的每一个键值对叫做一个Entry，这些Entry分散的存储在一个数组中，该数组就是HashMap的主干；
- 链表：因为数组的长度是有限的，使用hash函数计算时可能会出现索引冲突的情况，所以需要使用链表来解决冲突；此时数组的每一个元素不单纯只是一个Entry对象，它还是一个链表的头节点，每一个Entry对象通过Next指针指向下一个Entry节点，当新来的Entry映射到冲突的数组位置时，只需要插入对应的链表位置即可；
- 红黑树：当链表长度超过==阈值==时，会将链表转换为红黑树，使HashMap的性能得到进一步提升；

**阈值**：官方默认：链表的长度达到8个，或者是数组的长度达到64个

**阈值是多少**：

## 3  JVM虚拟机

### 3.1 Java垃圾回收机制

垃圾回收是Java虚拟机（JVM）垃圾回收器提供的一种用于在空闲时间不定时回收无任何引用的对象占据的内存空间的一种机制。

**如何判断对象已经死亡**：

- 引用计数法：给对象添加一个引用计数器，每当有一个地方引用，计数器加1；当引用失效，计数器减1；当计数器为0的时候对象不可再被使用（目前主流的虚拟机中并没有选择这个算法来管理内存，主要是因为它很难解决对象之间相互循环引用的问题）
- 可达性分析：通过一系列的被称为“GC ROOTS”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径被称为引用链，当一个对象到“GC ROOTS”没有任何引用链相连的时候，则证明此对象是不可用的。（不可达的对象并非“非死不可”，还需要经过两次标记过程，第一次标记并进行第一次筛选，筛选条件是此对象是否有必要执行finalize方法，当对象没有覆盖finalize方法，或finalize方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行；被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。）

**垃圾收集算法**：

- 标记-清除
- 复制
- 标记-整理
- 分代收集

**垃圾收集器**：

- Serial收集器：串行收集器，是一个单线程收集器，它在进行垃圾收集工作的时候必须暂停其他所有的工作线程，直到收集结束。优点：简单而高效，没有线程交互的开销；
- ParNew收集器：Serial收集器的多线程版本，除了使用多线程进行垃圾收集，其余行为和Serial收集器完全一样；
- Parallel Scavenge收集器：使用标记-复制算法的多线程收集器，关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）
- Serial Old收集器：Serial收集器的老年代版本；
- Parallel Old收集器：Parallel Scavenge收集器的老年代版本；
- CMS收集器：以获取最短回收停顿时间为目标的收集器，它第一次实现了让垃圾收集器线程与用户线程（基本上）同时工作；
- G1收集器：
- ZGC收集器：

### 3.2 说一下Java虚拟机的内存

Java虚拟机会自动管理内存，不容易出现内存泄漏和内存溢出等问题。Java虚拟机会在执行过程中将管理的内存分为若干个不同的数据区域，不同区域负责不同的功能。

**线程共享区域**：堆、方法区、直接内存

**线程私有区域**：虚拟机栈、本地方法栈、程序计数器

- 程序计数器：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响。（此区域是唯一一个虚拟机规范中没有规定任何OutOfMemoryError情况的区域）
- 虚拟机栈是线程私有的，每创建一个线程，虚拟机就会为这个线程创建一个虚拟机栈

### 3.3 内存泄露/内存溢出

**内存泄露**

定义：无用对象持续占有内存或者无用对象的内存得不到及时释放，从而造成内存空间的浪费

原因：JVM虚拟机是使用引用计数法和可达性分析来判断对象是否可回收，本质上是判断一个对象是否还被引用，如果没有引用则回收，可能会出现让垃圾回收机制误以为对象还在引用中，无法回收，造成内存泄露。

情况举例：1. 代码中没有及时释放，导致内存无法回收； 2. 资源未关闭（如数据库连接、文件读写等）； 3. 全局缓存持有的对象在不用的时候没有及时移除； 4.使用监听器时，释放对象时没有相应地删除监听器；

解决方法：1. 尽量少使用静态变量，或者使用完及时赋值为null； 2. 在对多个String对象进行字符串连接时，使用StringBuffer或StringBuilder进行字符串连接（直接使用String对象进行连接会产生大量临时字符串）； 3. 尽量缩小对象的作用域，能用局部变量就不用全局变量； 4. 各种连接注意关闭操作。

**内存溢出**

定义：程序在申请内存时，没有足够的空间供其使用

堆内存溢出报错：OutOfMemoryError:java heap space

栈溢出：StackOverflowError

**什么情况会OOM**：

1. 堆内存溢出：Java heap space
2. 永久代溢出：PermGen space（方法区溢出）
3. StackOverflowError

### 3.4 Java中堆和栈的区别

- 栈内存主要用来存放基本数据类型和引用变量，堆内存用来存放运行时创建的对象（如通过new关键字创建出来的对象）
- 相比于堆，栈的存取速度更快，但栈的大小和生存期是确定的，因此缺乏一定的灵活性

## 4 Java并发/多线程

线程：程序在执行过程中，能够执行程序代码的一个执行单元，在Java语言中，线程有四种状态：运行、就绪、挂起和结束；

进程：一段正在执行的程序，线程被称为轻量级进程，它是程序执行的最小单元，一个进程可以有多个线程，各个线程之间共享程序的内存空间及一些进程级的资源（例如打开的文件），但是各个线程拥有自己的栈空间。

### 4.1 新建线程的四种方式

1. 继承Thread类来创建线程(不适合资源共享)
2. 实现Runnable接口（很容易实现资源共享）
3. 使用Callable和Future创建线程
4. 使用线程池创建线程

### 4.2 结束线程的三种方法

1. 设置退出标志，使线程正常退出，也就是当run()方法完成后线程终止；
2. 使用interrupt()方法中断线程；
3. 使用stop()方法强行终止线程；

### 4.3 Start和Run方法的区别

- run() 方法只是Thread类中的一个方法，调用Run()方法不会新建线程，仍在主线程中执行任务；
- start()方法会新建一个子线程并执行run()方法中的内容，调用start()方法会有两个线程，一个是当前正在调用start()的主线程，一个是JVM创建的子线程，用来执行run()的内容

### 4.4 volatile关键字

**定义**：一种轻量级锁，保证了共享变量的==可见性==（当一个线程修改一个共享变量时，另外一个线程能够读到这个修改的值）和==有序性==（禁止指令重排序），volatile只能作用于单一变量，不能作用于方法（volatile不能保证操作的原子性，因此，一般情况下，volatile不能用来代替synchronized）

可见性：写共享变量时，既刷新到主内存，同时也将其他处理器缓存失效。

有序性：volatile的有序性是通过内存屏障来实现的，在屏障前的所有指令可以重排序，屏障后的指令也可以重排序，但是重排序的时候不能越过内存屏障

指令重排序：编译器重排序和处理器重排序

### 4.5 synchronized关键字

使用方式：1）修饰同步代码块 （锁对象是任意实例对象，用来维护秩序）、2）修饰实例方法（加锁对象是this）、3）修饰静态方法（锁对象是静态方法所在的Class类文件）  在使用synchronized关键字的时候需要指定一个对象，这个对象就是Monitor对象

作用：1）保证在同一时刻，只有一个线程可以执行某一个方法或者代码块； 2）确保可见性； 3）有效解决重排序问题

效率低的原因;synchronized通过Monitor实现线程同步，Monitor时依赖于底层互斥锁来实现线程的同步，而操作系统实现线程之间的切换需要从用户态转换到核心态，成本非常高。

### 4.6 锁

锁的四种状态：无锁、偏向锁、轻量级锁、重量级锁，他们会随着竞争的激烈逐渐升级，但是锁不可以降级，这种机制是为了获得锁和释放锁的效率。

偏向锁：适用于只有一个线程访问同步块的场景

轻量级锁：通过CAS操作和自旋来解决加锁问题，避免线程阻塞而影响性能。轻量级锁适合追求响应时间，锁占用时间很短的场景。

重量级锁：将除了拥有锁的线程以外的线程都阻塞。适合追求吞吐量、锁占用时间较长的场景。

### 4.7 sleep()和wait()的区别

1. wait必须搭配synchronize一起使用，而sleep不需要；
2. 进入wait状态的线程能够被notify和notifyAll唤醒，而sleep状态的线程不能被notify唤醒。
3. sleep仅仅让线程处于睡眠状态，等到计时时间一到，此线程会自动苏醒；而wait通常有条件的执行，线程会一直处于wait状态，直到某个条件变为真。

### 4.8 多线程同步的实现？

1. synchronized关键字
2. wait()和notify()方法
3. Lock（ReetrantLock）

### 4.9  synchronized于lock的区别

1. 用法不一样：synchronized既可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象；而lock需要显示地指定起始位置和终止位置；
2. 性能不一样：在资源竞争不是很激烈的情况下，synchronized的性能更优；但是在资源竞争很激烈的情况下，synchronized的性能会下降的非常快；
3. 锁机制不一样：synchronized获得锁和释放锁的方式都是在快结构中，当获取多个锁时必须以相反的顺序释放锁；而lock则需要开发人员手动去释放，并且必须在finally块中释放；

### 4.10  守护线程

Java提供了两种线程：守护线程和用户线程；

- 守护线程：程序运行时在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分；通俗的讲，任何一个守护线程都是整个JVM中所有非守护线程的“保姆”；
- 用户线程：用户程序执行时创建的线程，当所有用户线程全部退出运行时，只剩下守护线程存在时，JVM也就退出了；

### 4.11 join方法的作用

join() 方法的作用是让调用该方法的线程在执行完run()方法后，再执行join()方法后面的代码

## 5  其他

### 5.1 输入输出流

1. 字节流：InputStream、OutputStream（字节流在处理输入输出时不会用到缓存）
2. 字符流：Reader、Writer（字符流处理输入输出时用到了缓存）

### 5.2 Class.forName的作用是什么？

Class.forName()方法的作用就是将类加载到JVM中，Java中，类只有加载到JVM中才可以运行。

### 5.3 什么是Lambda表达式？

Lambda表达式允许将函数作为参数传递进方法中，可以取代大部分的匿名内部类。

### 5.4 Java泛型

定义：在创建或调用方法的时候才明确具体的类型